local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Chicha" .. Fluent.Version,
    SubTitle = "by dawid",
    TabWidth = 160,
    Size = UDim2.fromOffset(400, 320),
    Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}
--- Function
function Round6(number)
    local roundedNumber = math.floor(number * 10^6 + 0.5) / 10^6
    return string.format("%.6f", roundedNumber)
end
----

------
--     local Input = Tabs.Main:AddInput("Input", {
--         Title = "Webhook",
--         Default = "Default",
--         Placeholder = "Placeholder",
--         Numeric = false, -- Only allows numbers
--         Finished = false, -- Only calls callback when you press enter
--         Callback = function(Value)
--             print("Input changed:", Value)
--             local modifiedWebhookLink = string.gsub(wh, "discord.com", "webhook.lewistehminerz.dev")
--             webhooklink = tostring(modifiedWebhookLink)
--         end
--     })

--     Input:OnChanged(function()
--         print("Input updated:", Input.Value)
--     end)
-- end
---------
-- HUGE WEBHOOK
-- local Toggle = Tabs.Main:AddToggle("Huge", {Title = "Huge WH", Default = false })

-- Toggle:OnChanged(function()
--     spawn(monitorAndNotifyHugePetIncreases)
-- end)

-- Options.Huge:SetValue(false)
------
-- Aull Input
-- local Input = Tabs.Main:AddInput("Username", {
--     Title = "Username",
--     Default = "DarKuSXzzzz",
--     Placeholder = "Placeholder",
--     Numeric = false, -- Only allows numbers
--     Finished = false, -- Only calls callback when you press enter
--     Callback = function(Value)
--         print("Input changed:", Value)
--         username = user
--     end
-- })

-- Input:OnChanged(function()
--     print("Input updated:", Input.Value)
-- end)
-- end

-- local Input = Tabs.Main:AddInput("Shard Amount", {
--     Title = "Shard Amount",
--     Default = "100",
--     Placeholder = "Placeholder",
--     Numeric = true, -- Only allows numbers
--     Finished = false, -- Only calls callback when you press enter
--     Callback = function(Value)
--         print("Input changed:", Value)
--         shardAmount = tonumber(shards)
--         gemAmount = tonumber(gems)
--     end
-- })

-- Input:OnChanged(function()
--     print("Input updated:", Input.Value)
-- end)
-- end

-- local Input = Tabs.Main:AddInput("Gem Amount", {
--     Title = "Gem Amount",
--     Default = "50000",
--     Placeholder = "Placeholder",
--     Numeric = true, -- Only allows numbers
--     Finished = false, -- Only calls callback when you press enter
--     Callback = function(Value)
--         print("Input changed:", Value)
        
--     end
-- })

-- Input:OnChanged(function()
--     print("Input updated:", Input.Value)
-- end)
-- end
---- Auto Mail
local Toggle = Tabs.Main:AddToggle("autoMail", {Title = "Auto Mail", Default = false })

Toggle:OnChanged(function()
    spawn(autoMail)
end)

Options.autoMail:SetValue(false)
----------
-- Function Auto Mail
function autoMail()
    while task.wait() and Config.autoMail do
        local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
        local result = saveModule.Get()

        local ms = result.Inventory.Misc
        for i, v in pairs(ms) do
            if v.id == "Magic Shard" then
                if v._am >= shardAmount then
                    local args = {
                        [1] = username,
                        [2] = "Magic Shard",
                        [3] = "Misc",
                        [4] = i,
                        [5] = v._am or 1
                    }
                    game:GetService("ReplicatedStorage").Network:FindFirstChild("Mailbox: Send"):InvokeServer(
                        unpack(args)
                    )
                end
            end
        end

        task.wait(2)

        local pet = result.Inventory.Pet
        for i, v in pairs(pet) do
            if v.id == "Huge Poseidon Corgi" then
                local args = {
                    [1] = username,
                    [2] = "Huge Poseidon Corgi",
                    [3] = "Pet",
                    [4] = i,
                    [5] = v._am or 1
                }
                game:GetService("ReplicatedStorage").Network:FindFirstChild("Mailbox: Send"):InvokeServer(unpack(args))
            end
        end

        task.wait(2)

        local GetSave = function()
            return require(game.ReplicatedStorage.Library.Client.Save).Get()
        end
        for i, v in pairs(GetSave().Inventory.Currency) do
            if v.id == "Diamonds" then
                if v._am >= gemAmount then
                    local args = {
                        [1] = username,
                        [2] = v.id,
                        [3] = "Currency",
                        [4] = i,
                        [5] = gemAmount - 10000
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Mailbox: Send"):InvokeServer(unpack(args))
                end
            end
            task.wait(1)
        end
    end
end
------------
-- Function Wenhook
function sendWebhookMessage(embed)
    local syn = syn or {}
    local request = syn.request or http_request or request
    local success, response = pcall(function()
        return request({
            Url = webhooklink,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                content = "@everyone",
                embeds = {embed}
            })
        })
    end)
    if not success then
        warn("Failed to send webhook message:", response)
    end
end    

function countHugePets()
    local Library = require(game.ReplicatedStorage.Library)
    local Save = Library.Save.Get().Inventory
    local AmountOfHuges = 0
    for _, v in pairs(Save.Pet) do
        local id = v.id
        local dir = Library.Directory.Pets[id]
        if dir.huge then
            AmountOfHuges = AmountOfHuges + 1
        end
    end
    return AmountOfHuges
end

function monitorAndNotifyHugePetIncreases()
    local previousAmountOfHuges = countHugePets()
    local lp = game.Players.LocalPlayer.Name
    while true do
        if Config.hugeNotify then
            local currentAmountOfHuges = countHugePets()
            if currentAmountOfHuges > previousAmountOfHuges then
                local embed = {
                    title = "**ðŸŒŸ HUGE PET ALERT! ðŸŒŸ**",
                    description = lp .. " got a huge!",
                    color = 0xEE4B2B,
                }
                sendWebhookMessage(embed)
                previousAmountOfHuges = currentAmountOfHuges
            end
        end
        wait(0.5)
    end
end

local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
local HttpService = game:GetService("HttpService")

function sendWebhookMessage(embed)
    local syn = syn or {}
    local request = syn.request or http_request or request
    local success, response = pcall(function()
        return request({
            Url = webhooklink,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                content = "@everyone",
                embeds = {embed}
            })
        })
    end)
    if not success then
        warn("Failed to send webhook message:", response)
    end
end    

function countCharmStones()
    local result = saveModule.Get()
    local cs = result.Inventory.Misc
    local charmStoneCount = 0
    for i, v in pairs(cs) do
        if v.id == "Charm Stone" then
            charmStoneCount = charmStoneCount + (v._am or 1)
        end
    end
    return charmStoneCount
end

function monitorAndNotifyCSIncreases()
    local previousCharmStoneCount = countCharmStones()
    local lp = game.Players.LocalPlayer.Name
    local debounce = false

    while true do
        if Config.csNotify and not debounce then
            local currentCharmStoneCount = countCharmStones()
            if currentCharmStoneCount > previousCharmStoneCount then
                debounce = true
                local embed = {
                    title = "Charm Stone!",
                    description = lp .. " got a charm stone!",
                    color = 0x66FF00,
                }
                sendWebhookMessage(embed)
                previousCharmStoneCount = currentCharmStoneCount

                wait(1)
                debounce = false
            end
        end
        wait(0.5)
    end
end

local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
local HttpService = game:GetService("HttpService")

function sendWebhookMessage(embed)
    local syn = syn or {}
    local lp = game.Players.LocalPlayer.Name
    local request = syn.request or http_request or request
    local success, response = pcall(function()
        return request({
            Url = webhooklink,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                content = "@everyone",
                embeds = {embed}
            })
        })
    end)
    if not success then
        warn("Failed to send webhook message:", response)
    end
end    

function countMagicShards()
    local result = saveModule.Get()
    local ms = result.Inventory.Misc
    local magicShardCount = 0
    for i, v in pairs(ms) do
        if v.id == "Magic Shard" then
            magicShardCount = magicShardCount + (v._am or 1)
        end
    end
    return magicShardCount
end

function monitorAndNotifyMSIncreases()
    local previousMagicShardCount = countMagicShards()
    local lp = game.Players.LocalPlayer.Name
    local debounce = false

    while true do
        if Config.msNotify and not debounce then
            local currentMagicShardCount = countMagicShards()
            if currentMagicShardCount > previousMagicShardCount then
                debounce = true
                local embed = {
                    title = "Magic Shard!",
                    description = lp .. " got a magic shard!",
                    color = 0xA020F0,
                }
                sendWebhookMessage(embed)
                previousMagicShardCount = currentMagicShardCount

                wait(1)
                debounce = false
            end
        end
        wait(0.5)
    end
end 
------



Window:SelectTab(6)
SaveManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
SaveManager:SetFolder("MuimiHub/specific-game")
SaveManager:BuildConfigSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()
