local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Chicha" .. Fluent.Version,
    SubTitle = "by dawid",
    TabWidth = 160,
    Size = UDim2.fromOffset(400, 320),
    Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

do
    Fluent:Notify({
        Title = "Notification",
        Content = "This is a notification",
        SubContent = "SubContent", -- Optional
        Duration = 5 -- Set to nil to make the notification not disappear
    })



    Tabs.Main:AddParagraph({
        Title = "Paragraph",
        Content = "This is a paragraph.\nSecond line!"
    })



    Tabs.Main:AddButton({
        Title = "Button",
        Description = "Very important button",
        Callback = function()
            Window:Dialog({
                Title = "Title",
                Content = "This is a dialog",
                Buttons = {
                    {
                        Title = "Confirm",
                        Callback = function()
                            print("Confirmed the dialog.")
                        end
                    },
                    {
                        Title = "Cancel",
                        Callback = function()
                            print("Cancelled the dialog.")
                        end
                    }
                }
            })
        end
    })
    
    -- local Slider = Tabs.Main:AddSlider("Slider", {
    --     Title = "Slider",
    --     Description = "This is a slider",
    --     Default = 2,
    --     Min = 0,
    --     Max = 5,
    --     Rounding = 1,
    --     Callback = function(Value)
    --         print("Slider was changed:", Value)
    --     end
    -- })

    -- Slider:OnChanged(function(Value)
    --     print("Slider changed:", Value)
    -- end)

    -- Slider:SetValue(3)



    -- local Dropdown = Tabs.Main:AddDropdown("Dropdown", {
    --     Title = "Dropdown",
    --     Values = {"one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen"},
    --     Multi = false,
    --     Default = 1,
    -- })

    -- Dropdown:SetValue("four")

    -- Dropdown:OnChanged(function(Value)
    --     print("Dropdown changed:", Value)
    -- end)


    
    -- local MultiDropdown = Tabs.Main:AddDropdown("MultiDropdown", {
    --     Title = "Dropdown",
    --     Description = "You can select multiple values.",
    --     Values = {"one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen"},
    --     Multi = true,
    --     Default = {"seven", "twelve"},
    -- })

    -- MultiDropdown:SetValue({
    --     three = true,
    --     five = true,
    --     seven = false
    -- })

    -- MultiDropdown:OnChanged(function(Value)
    --     local Values = {}
    --     for Value, State in next, Value do
    --         table.insert(Values, Value)
    --     end
    --     print("Mutlidropdown changed:", table.concat(Values, ", "))
    -- end)



    -- local Colorpicker = Tabs.Main:AddColorpicker("Colorpicker", {
    --     Title = "Colorpicker",
    --     Default = Color3.fromRGB(96, 205, 255)
    -- })

    -- Colorpicker:OnChanged(function()
    --     print("Colorpicker changed:", Colorpicker.Value)
    -- end)
    
    -- Colorpicker:SetValueRGB(Color3.fromRGB(0, 255, 140))



    -- local TColorpicker = Tabs.Main:AddColorpicker("TransparencyColorpicker", {
    --     Title = "Colorpicker",
    --     Description = "but you can change the transparency.",
    --     Transparency = 0,
    --     Default = Color3.fromRGB(96, 205, 255)
    -- })

    -- TColorpicker:OnChanged(function()
    --     print(
    --         "TColorpicker changed:", TColorpicker.Value,
    --         "Transparency:", TColorpicker.Transparency
    --     )
    -- end)



    -- local Keybind = Tabs.Main:AddKeybind("Keybind", {
    --     Title = "KeyBind",
    --     Mode = "Toggle", -- Always, Toggle, Hold
    --     Default = "LeftControl", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

    --     -- Occurs when the keybind is clicked, Value is `true`/`false`
    --     Callback = function(Value)
    --         print("Keybind clicked!", Value)
    --     end,

    --     -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
    --     ChangedCallback = function(New)
    --         print("Keybind changed!", New)
    --     end
    -- })

    -- OnClick is only fired when you press the keybind and the mode is Toggle
    -- Otherwise, you will have to use Keybind:GetState()
    -- Keybind:OnClick(function()
    --     print("Keybind clicked:", Keybind:GetState())
    -- end)

    -- Keybind:OnChanged(function()
    --     print("Keybind changed:", Keybind.Value)
    -- end)

    -- task.spawn(function()
    --     while true do
    --         wait(1)

    --         -- example for checking if a keybind is being pressed
    --         local state = Keybind:GetState()
    --         if state then
    --             print("Keybind is being held down")
    --         end

    --         if Fluent.Unloaded then break end
    --     end
    -- end)

    -- Keybind:SetValue("MB2", "Toggle") -- Sets keybind to MB2, mode to Hold

------
    local Input = Tabs.Main:AddInput("Input", {
        Title = "Input",
        Default = "Default",
        Placeholder = "Placeholder",
        Numeric = false, -- Only allows numbers
        Finished = false, -- Only calls callback when you press enter
        Callback = function(Value)
            print("Input changed:", Value)
            local modifiedWebhookLink = string.gsub(wh, "discord.com", "webhook.lewistehminerz.dev")
            webhooklink = tostring(modifiedWebhookLink)
        end
    })

    Input:OnChanged(function()
        print("Input updated:", Input.Value)
    end)
end
---------
-- HUGE WEBHOOK
local Toggle = Tabs.Main:AddToggle("Huge", {Title = "Huge WH", Default = false })

Toggle:OnChanged(function()
    spawn(monitorAndNotifyHugePetIncreases)
end)

Options.Huge:SetValue(false)
--
---- Auto Mail
local Toggle = Tabs.Main:AddToggle("autoMail", {Title = "Auto Mail", Default = false })

Toggle:OnChanged(function()
    spawn(autoMail)
end)

Options.autoMail:SetValue(false)
----------
-- Function Auto Mail
function autoMail()
    while task.wait() and Config.autoMail do
        local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
        local result = saveModule.Get()

        local ms = result.Inventory.Misc
        for i, v in pairs(ms) do
            if v.id == "Magic Shard" then
                if v._am >= shardAmount then
                    local args = {
                        [1] = username,
                        [2] = "Magic Shard",
                        [3] = "Misc",
                        [4] = i,
                        [5] = v._am or 1
                    }
                    game:GetService("ReplicatedStorage").Network:FindFirstChild("Mailbox: Send"):InvokeServer(
                        unpack(args)
                    )
                end
            end
        end

        task.wait(2)

        local pet = result.Inventory.Pet
        for i, v in pairs(pet) do
            if v.id == "Huge Poseidon Corgi" then
                local args = {
                    [1] = username,
                    [2] = "Huge Poseidon Corgi",
                    [3] = "Pet",
                    [4] = i,
                    [5] = v._am or 1
                }
                game:GetService("ReplicatedStorage").Network:FindFirstChild("Mailbox: Send"):InvokeServer(unpack(args))
            end
        end

        task.wait(2)

        local GetSave = function()
            return require(game.ReplicatedStorage.Library.Client.Save).Get()
        end
        for i, v in pairs(GetSave().Inventory.Currency) do
            if v.id == "Diamonds" then
                if v._am >= gemAmount then
                    local args = {
                        [1] = username,
                        [2] = v.id,
                        [3] = "Currency",
                        [4] = i,
                        [5] = gemAmount - 10000
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Mailbox: Send"):InvokeServer(unpack(args))
                end
            end
            task.wait(1)
        end
    end
end
------------
-- Function Wenhook
function sendWebhookMessage(embed)
    local syn = syn or {}
    local request = syn.request or http_request or request
    local success, response = pcall(function()
        return request({
            Url = webhooklink,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                content = "@everyone",
                embeds = {embed}
            })
        })
    end)
    if not success then
        warn("Failed to send webhook message:", response)
    end
end    

function countHugePets()
    local Library = require(game.ReplicatedStorage.Library)
    local Save = Library.Save.Get().Inventory
    local AmountOfHuges = 0
    for _, v in pairs(Save.Pet) do
        local id = v.id
        local dir = Library.Directory.Pets[id]
        if dir.huge then
            AmountOfHuges = AmountOfHuges + 1
        end
    end
    return AmountOfHuges
end

function monitorAndNotifyHugePetIncreases()
    local previousAmountOfHuges = countHugePets()
    local lp = game.Players.LocalPlayer.Name
    while true do
        if Config.hugeNotify then
            local currentAmountOfHuges = countHugePets()
            if currentAmountOfHuges > previousAmountOfHuges then
                local embed = {
                    title = "**🌟 HUGE PET ALERT! 🌟**",
                    description = lp .. " got a huge!",
                    color = 0xEE4B2B,
                }
                sendWebhookMessage(embed)
                previousAmountOfHuges = currentAmountOfHuges
            end
        end
        wait(0.5)
    end
end

local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
local HttpService = game:GetService("HttpService")

function sendWebhookMessage(embed)
    local syn = syn or {}
    local request = syn.request or http_request or request
    local success, response = pcall(function()
        return request({
            Url = webhooklink,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                content = "@everyone",
                embeds = {embed}
            })
        })
    end)
    if not success then
        warn("Failed to send webhook message:", response)
    end
end    

function countCharmStones()
    local result = saveModule.Get()
    local cs = result.Inventory.Misc
    local charmStoneCount = 0
    for i, v in pairs(cs) do
        if v.id == "Charm Stone" then
            charmStoneCount = charmStoneCount + (v._am or 1)
        end
    end
    return charmStoneCount
end

function monitorAndNotifyCSIncreases()
    local previousCharmStoneCount = countCharmStones()
    local lp = game.Players.LocalPlayer.Name
    local debounce = false

    while true do
        if Config.csNotify and not debounce then
            local currentCharmStoneCount = countCharmStones()
            if currentCharmStoneCount > previousCharmStoneCount then
                debounce = true
                local embed = {
                    title = "Charm Stone!",
                    description = lp .. " got a charm stone!",
                    color = 0x66FF00,
                }
                sendWebhookMessage(embed)
                previousCharmStoneCount = currentCharmStoneCount

                wait(1)
                debounce = false
            end
        end
        wait(0.5)
    end
end

local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
local HttpService = game:GetService("HttpService")

function sendWebhookMessage(embed)
    local syn = syn or {}
    local lp = game.Players.LocalPlayer.Name
    local request = syn.request or http_request or request
    local success, response = pcall(function()
        return request({
            Url = webhooklink,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                content = "@everyone",
                embeds = {embed}
            })
        })
    end)
    if not success then
        warn("Failed to send webhook message:", response)
    end
end    

function countMagicShards()
    local result = saveModule.Get()
    local ms = result.Inventory.Misc
    local magicShardCount = 0
    for i, v in pairs(ms) do
        if v.id == "Magic Shard" then
            magicShardCount = magicShardCount + (v._am or 1)
        end
    end
    return magicShardCount
end

function monitorAndNotifyMSIncreases()
    local previousMagicShardCount = countMagicShards()
    local lp = game.Players.LocalPlayer.Name
    local debounce = false

    while true do
        if Config.msNotify and not debounce then
            local currentMagicShardCount = countMagicShards()
            if currentMagicShardCount > previousMagicShardCount then
                debounce = true
                local embed = {
                    title = "Magic Shard!",
                    description = lp .. " got a magic shard!",
                    color = 0xA020F0,
                }
                sendWebhookMessage(embed)
                previousMagicShardCount = currentMagicShardCount

                wait(1)
                debounce = false
            end
        end
        wait(0.5)
    end
end 
------
--- Function
function Round6(number)
    local roundedNumber = math.floor(number * 10^6 + 0.5) / 10^6
    return string.format("%.6f", roundedNumber)
end
----


Window:SelectTab(6)
SaveManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
SaveManager:SetFolder("MuimiHub/specific-game")
SaveManager:BuildConfigSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()
